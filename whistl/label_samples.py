'''This script reads in an aggregated_metadata file generated by refine.bio and allows the user
to label gene expression samples based on the metadata'''

import argparse
import json
import os
import pickle
import sys


def unlabel_samples(labeled_samples, set_of_labeled_samples):
    '''Allow the user to remove samples' labels so they can be relabeled later

    Arguments
    ---------
    labeled_samples: dict of lists of strs
        The current sample labels
    set_of_labeled_samples: set of strs
        The set of all labeled samples

    Returns
    -------
    The updated versions of labeled_samples and set_of_labeled_samples
    '''
    while True:
        print('Would you like to unlabel samples?')

        choice = input('yes/no: ').strip().lower()
        if choice == 'no':
            return labeled_samples, set_of_labeled_samples
        elif choice == 'yes':
            print('Current sample labels:')
            print(labeled_samples)

            sample = input('Sample to remove: ').strip().upper()
            if sample in set_of_labeled_samples:
                set_of_labeled_samples.remove(sample)
                for key in labeled_samples:
                    if sample in labeled_samples[key]:
                        labeled_samples[key].remove(sample)
                print('Sample unabeled.')
            else:
                print('Sample not found...')
        else:
            print('{} is not a valid option'.format(choice))


def edit_fields(fields, sample_data):
    '''Allow the user to change which metadata will be printed by default

    Arguments
    ---------
    fields: set of str
        The current fields to print
    sample_data: json object
        The metadata about the sample for use in labeling

    Returns
    -------
    fields: set of str
        The updated fields to print
    '''
    done_editing = False

    print('Current fields: {}'.format(fields))
    unused_fields = sample_data.keys()
    print('Fields available for this sample: {}'.format(unused_fields))
    while not done_editing:
        print()
        print('Do you want to add or remove a field?')
        choice = input('Add/remove/done: ').strip().lower()

        if choice == 'add':
            print('Which field would you like to add?')
            print('Available fields: {}'.format(unused_fields))
            choice = input('Field: ').strip().lower()

            if choice in unused_fields:
                if choice in fields:
                    print('{} has already been added'.format(choice))
                    continue
                fields.add(choice)
            else:
                print('{} is not a valid field'.format(choice))

        elif choice == 'remove':
            if len(fields) == 0:
                print('No fields to remove')

            print('Which field would you like to remove? Current fields: {}'.format(fields))
            choice = input('Field: ').strip().lower()

            if choice in fields:
                fields.remove(choice)
            else:
                print('{} not found in the current fields')

        elif choice == 'done':
            done_editing = True
        else:
            print('{} is not a valid option'.format(choice))

    return fields


def get_sample_label(sample_name, sample_data, valid_labels, fields):
    '''Prompt the user to provide a lable for the given sample

    Arguments
    ---------
    sample_name: str
        The sample's identifier
    sample_data: json object
        The metadata about the sample for use in labeling
    valid_labels: set of strs
        The labels the user can provide for the sample
    fields: list of strs
        The metadata to print by default for each sample

    Returns
    -------
    label: str
        The label from valid_labels to assign the sample to, or False if the user is done labeling
    '''

    label_selected = False
    while not label_selected:
        # Sometimes the refinebio_annotations field has multiple dictionaries, we want to show them
        # all. To do so, we just merge them together
        if len(sample_data['refinebio_annotations']) > 1:
            new_dict = {}
            # This is hacky, but I don't think lists have an apply function
            [new_dict.update(annotation) for annotation in sample_data['refinebio_annotations']]
            sample_data['refinebio_annotations'] = [new_dict]

        print('Sample: {}'.format(sample_name))
        # Print the default fields
        print(sample_data['refinebio_title'])
        if len(sample_data['refinebio_annotations']) == 0:
            print('No refinebio annotations found, sorry :(')
        else:
            for field in fields:
                if field in sample_data['refinebio_annotations'][0]:
                    print('{}: {}'.format(field, sample_data['refinebio_annotations'][0][field]))

        print()
        # Ask the user to provide a label
        print('Provide a label, ask for more information about the sample, '
              'print one of the sample\'s metadata fields, or quit')
        label = input('[<label>/info/field/quit/labels]:').strip().lower()
        if label == 'quit':
            return False
        elif label == 'info':
            print(json.dumps(sample_data, indent=4))
        elif label in valid_labels:
            label_selected = True
        elif label == 'labels':
            print('Current labels: {}'.format(valid_labels))
        elif label == 'field':
            fields = edit_fields(fields, sample_data['refinebio_annotations'][0])

        else:
            print()
            print('{} not a recognized option, please try again'.format(label))
            print()

    return label


def prompt_for_label(labels):
    '''Ask the user to add or remove a single label

    Arguments
    ---------
    labels: set of strs
        The labels already in use

    Returns
    -------
    labels: set of strs
        The labels provided by the user
    doneUpdating: bool
        True if the user is done updating labels, False otherwise
    '''
    print('Do you want to add a label, remove a label, or are you done creating labels')
    option = input('[add/remove/done]: ').strip().lower()

    if option == 'add':
        labels.add(input('Label to add: ').strip().lower())
    elif option == 'remove':
        if len(labels) == 0:
            print('There are currently no labels to remove')
        print('Current labels: {}'.format(labels))
        label = input('Label to remove: ').strip().lower()
        if label in labels:
            labels.remove(label)
        else:
            print('Sorry, {} was not found'.format(label))
    elif option == 'done':
        return labels, True
    else:
        print("Sorry, the recognized inputs are 'add', 'remove', or 'quit'")

    return labels, False


def update_labels(labels=set()):
    '''Ask the user which labels should be considered valid for categorizing samples

    Arguments
    ---------
    labels: set of strs
        The labels already in use

    Returns
    -------
    labels: set of strs
        The labels provided by the user
    '''

    doneAddingLabels = False

    while not doneAddingLabels:
        labels, doneAddingLabels = prompt_for_label(labels)

    return labels


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='This script reads in an aggregated_metadata '
                                                 'file generated by refine.bio and allows the '
                                                 'user to label gene expression samples based '
                                                 'on the metadata''')
    parser.add_argument('metadata', help='The file containing metadata for all samples in the '
                                         'dataset. By default, it will be named '
                                         'aggregated_metadata.json')
    parser.add_argument('out_file', help='Either the path to save the results to, or a file '
                                         'generated by an incomplete run of label_samples')

    args = parser.parse_args()

    metadata_file = open(args.metadata)
    metadata = json.load(metadata_file)

    labeled_samples = {}
    set_of_labeled_samples = set()
    if os.path.exists(args.out_file):
        with open(args.out_file, 'rb') as out_file:
            labeled_samples, set_of_labeled_samples = pickle.load(out_file)
        labels = set(labeled_samples.keys())

        choice = None
        while choice is None:
            print('Would you like to add more labels or continue categorizing samples with '
                  'your current labels?')
            choice = input('[more/current]: ').strip().lower()
            if choice == 'more':
                labels = update_labels(labels)
            elif choice == 'current':
                break
            else:
                print('{} is not a valid option'.format(choice))
                choice = None
    else:
        labels = update_labels()
        if len(labels) == 0:
            print('No labels found, exiting...')
            sys.exit()

        for label in labels:
            labeled_samples[label] = []

    try:
        fields = set()
        for sample in metadata['samples']:
            if sample in set_of_labeled_samples:
                continue
            sample_data = metadata['samples'][sample]
            sample_label = get_sample_label(sample, sample_data, labels, fields)
            if not sample_label:
                break
            if sample_label in labeled_samples:
                labeled_samples[sample_label].append(sample)
            else:
                labeled_samples[sample_label] = [sample]
            set_of_labeled_samples.add(sample)

        print('All samples are labeled!')

        # If the user makes a mistake, give them the option to unlabel samples
        labeled_samples, set_of_labeled_samples = unlabel_samples(labeled_samples,
                                                                  set_of_labeled_samples)

    finally:
        print('Saving results...')
        with open(args.out_file, 'wb') as out_file:
            pickle.dump((labeled_samples, set_of_labeled_samples), out_file)
